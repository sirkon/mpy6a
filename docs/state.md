# Состояние.

В данном материале мы рассмотрим центральный объект системы – её состояние.
Состояние хранит данные системы, которые разделяются на две части:

* Данные бизнес-логики. Далее просто **данные** – это то, ради чего всё это вообще нужно.
    * Текущий индекс состояния.
    * Текущий **индекс повтора**.
    * Данные активных сессий – они хранятся только в оперативной памяти.
    * Данные сохранённых сессий в оперативной памяти.
    * Данные сохранённых сессий в файлах.
    * Ссылки на такие файлы с указанием текущей позиции вычитки в них.
    * Итераторы по файлам и памяти, для вычитки сессий для повтора.
* Данные изменения состояния, это слепки состояния и логи операций (над состоянием). Такие данные будем далее называть
  **метаданными**. Это:
    * Указатель на последний слепок.
    * Ссылки на файлы с логами операций:
        * Индекс операций в таких файлах всегда упорядочен, поэтому имеет смысл говорить о старшей и младшей операции
          в файле.
        * Файлы операций так же имеют естественный порядок: старшая операция в файле созданном позже всегда младше
          самой младшей операции в файле созданном раньше. Поэтому имеет смысл говорить о старшинстве среди файлов тоже.
          Ссылка так же хранит индексы самой старшей и младшей операции в этом файле.
          Сюда включается и файл операций в данный момент находящийся в активном (для записи туда) состоянии. Т.е.
          у дескриптора лога операций есть флаг/метод активности.
    * Объект текущего лога операций. Только для записи туда.

Т.е. сессия определяется примерно как:

```go
package types

import (
    "sync"
    
    "github.com/sirkon/mpy6a/internal/types"
)

t // State определение состояния. 
type State struct {
    // бизнес-данные
    index     Index
    prevID    Index
    repeatID  uint64
    active    map[Index]*Session
    memstores *tree.RB[uint64, *Session]
    fsstores  map[Index]FSStore
    repeat    *RepeatIterators

    // метаданные
    snapid     Index
    oplogs     map[Index]*OPLogDescriptor
    actlog     *OPLogDescriptor
    log        *OPLog
    systemTime types.TimeAtomic

    // Данные для контроля над процессами.
    timeSignal *sync.Cond
    done       chan struct{}

    // Статистические данные.
    // Требования к ним слишком расплывчаты, чтобы мочь
    // описать их здесь в достаточно хорошем виде, поэтому
    // опускаем.
    …
}

```

## Индекс

Обычный RAFT-индекс, т.е. пара (срок, индекс в рамках срока). При смене индекса в prevID отправляется текущее значение
ID.

## Индекс повтора.

Повторы сессий у нас привязаны ко времени в секундах. Рассмотрим ситуацию определения, какие сессии нужно повторить.

Пусть у нас есть: 
- Сессия S<sub>1.1</sub> повторяющаяся в момент времени T<sub>1</sub> 
- Сессия и S<sub>1.2</sub> так же повторяющиеся в момент времени T<sub>1</sub>
- Сессия S<sub>2</sub> повторяющаяся в момент времени T<sub>2</sub> = T<sub>1</sub> + 1.

Настало время T = T<sub>1</sub>. Мы начинаем повтор S<sub>1.1</sub> и в момент выполнения процедур необходимых
для повтора астрономическое время изменяется на T = T<sub>2</sub>.

Вроде бы ерунда – мы же можем рассматривать сессии чей повтор начинается не позднее текущего времени, т.е.  
T(S) ≤ T. Но тогда становится возможным, что сессия с повтором на секунду позже начинает его в то же время, если 
вообще не раньше.

Можно, конечно, их сортировать после нахождения, но всё это выглядит не очень. Поэтому предлагается ввести т.н.
**индекс повтора**, для которого выполняется:

- Равен астрономическому времени в секундах в момент свежего старта.
- Если есть сессии к повтору для времён `T...T'`, где `T` – текущий индекс повтора, а `T'` –  астрономическое время, то 
  устанавливаем индекс повтора равным времени для ближайшего повтора.

Подробнее об индексе повтора и повторах вообще можно посмотреть в [этом](repeat_process.md) материале.

## Канал backStoreTask

Используется для проведения фоновых операций, которые, как следует из способа задания, могут выполняться
только строго по одной. В их число входят:

- Сброс данных повторов сессий из памяти на диск.
- Объединение файлов с повторами.

## Канал done

Закрывается когда отдана команда на остановку системы.

# Слепки состояний.

В слепки состояний входят:

- Индекс состояния.
- Индекс повтора.
- Активные сессии как список пар – подробности ниже.
- Сохранённые в память сессии.
- Список дескрипторов файлов с повторами сессий – подробности ниже.
- Указатель на файл операций с позицией записи в нём на момент начала создания слепка.

## Активные сессии.

Активные сессии сохраняются как

| uleb128(N) | Данные сессии 1 | … | Данные сессии N |
|------------|-----------------|---|-----------------|

Где N - количество активных сессий, а "данные сессии X" кодируются как описано в [материале по ним](./session.md).

## Список дескрипторов файлов.

Кодируется как

| uleb128(M) | Кодировка файла 1 | … | Кодировка файла M |
|------------|-------------------|---|-------------------|

Где M - количество файлов с повторами, а "кодировка файла X" есть

| Индекс файла (Index) | Позиция чтения в файле (uint64) |
|----------------------|---------------------------------|


# Время системы.

Нам, для вычисления время повтора сессий, нужно знать текущее астрономическое время в секундах. И имеем
следующие факторы.

- Трудоёмкость операции получения текущего времени, которая приводит к системному вызову.
- То, что мы работаем в рамках секунды, без учёта долей.
- Постановщик повторов может оставаться без работы и должен иметь механизм ожидания если не до появления
  ближайшего повтора, то хотя бы до следующей секунды, где он может проверить наличие новых. 

Тикер при этом подходит не очень, потому что даёт постоянно увеличивающуюся ошибку, нам нужен тикер который
бы постоянно её корректировал.

Поэтому предлагается завести следующее

```go

// Тикер вращается постоянно и не реагирует на остановку – это нормально,
// поскольку он всё равно не держит никаких значимых ресурсов.
func (s *State) ticker() {
    for {
        s.timeSignal.L.Lock()
        now := time.Now().Truncate(time.Millisecond)
        s.systemTime.Set(now)
        s.timeSignal.Broadcast()
        s.timeSignal.L.Unlock()
        
        // Ждём прихода следующей секунды. То, что это действительно
        // будет следующая секунда не гарантируется, из-за тормозов
        // может быть и пропуск. 
        // 
        // PS мы не подходим для RTOS (
        time.Sleep(now.Add(time.Second).Sub(time.Now()))
    }
}

// Получение текущего времени.
func (s *State) now() time.Time {
    return s.systemTime.Get()
}

func (s *State) waitTillNextSecond() {
    s.timeSignal.L.Lock()
    s.timeSignal.Wait()
    s.timeSignal.L.Unlock()
}
```
