# Создание слепков.

Сам формат слепков был описан [здесь](state.md#слепки-состояний), и здесь ему не место, т.к. он тесно связан с 
содержимым состояния. Здесь же мы опишем само это действие.

Так же нужно изучить [материал](logs.md) по логам.

## Инициирование создания слепка.

Само решение о создании слепка является следствием излишне распухшего лога операций – излишне распухший лог операций 
приводит к увеличению времени запуска. Т.е., фактически, операция создания слепка состояния делается из-за лога операций
и должна как создавать слепок, так и ротировать лог. Естественно, эта операция НЕ ДОЛЖНА быть блокирующей, т.е.
система должна продолжать функционировать в штатном состоянии, если смотреть с точки зрения её пользователей.

## Непосредственное создание и завершение создания нового слепка.

1. Непосредственное начало операции осуществляется с помощью инъекции соответствующей сущности в первую очередь 
   операций. 
2. Внедрённая операция, по достижении своей очереди:
   1. Делает полную копию состояния.
   2. Запускает процесс кодирования состояния и сброса его на диск.
   3. Создаёт новый пустой файл лога, но не заменяет его, а добавляет его как **вторичный**. **С этого момента все 
      операции сохраняются как в текущий лог, так и во вторичный**. 
3. По достижении конца кодирования, в случае как успеха, так и неудачи, в очередь операций добавляется новая:
   - Для удачного кодирования она:
     1. Добавит путь нового слепка в соответствующий лог слепков.
     2. Заменит текущий лог и дескриптор лога в состоянии на вторичный.
   - Для неудачного просто обнулит вторичный лог.

Заметим, что все операции производятся в "постоянных" временных файлах. Это означает что временные файлы всегда
имеют одно и то же название – чтобы не плодить, потенциально, мусор. В случае удачного завершения они переименовываются
в "индексный" вид – со значением индекса предшествующей операции:

- Сначала переименовывается слепок. В случае неудачи сбрасываемся на "неудачную" ветвь завершающей операции.
- Затем переименовывается лог. В случае неудачи удаляем переименованный слепок и сбрасываемся на неудачную ветвь.

## Коллизии с фоновыми процессами сохранения контейнера и слияния источников.

Эти процессы не должны пересекаться: представим ситуацию, когда процесс слияния источников работал до начала
создания слепка/ротации лога и был в процессе слияния в момент инициации ротации. 
При успешном завершении слияния в состоянии появится новый источник. Но, операция начала слияния в логе не отражена. 
Это означает, что при перезапуске этот источник будет потерян. Сами данные потеряны при этом не будут, т.к.
контейнер будет заменён лишь при окончании – при рестарте этого окончания не будет. Но останется файл, который
нигде не зарегистрирован и болтается сам по себе на файловой системе. Аналогично и для процесса сброса контейнера.

Поэтому необходимым условием появления самой задачи по ротации является отсутствие этих двух фоновых процессов в это
время. Эта задача решается внедрением канала, в который система изначально пишет "слот", а затем эти фоновые процессы,
по выполнению их соответствующих критериев, пытаются прочесть. При успешном получении слота они проводят свои операции
и, по их завершении, пишут слот в обозначенный канал опять.

