# Разбор процесса выполнения операций.

В данном документе формулируется методика выполнения операций над машиной состояний.

## Операции с машины состояний.

Они описываются следующим интерфейсом:

```go
type State interface{
    // New создание новой сессии с заданной темой и первым куском данных в ней.
    New(theme uint32, data []byte) (Session, error)
	
	// Append добавление нового куска данных в заданную сессию.
    Append(session Session, data []byte) error
	
	// Replace замена имеющихся кусков данных в сессии на данный.
	Replace(session Session, data []byte) error
	
	// Remove удаление данной сессии.
	Remove(session Session) error
	
	// Store сохранение данной сессии с указанным в секундах временем повтора.
	Store(session Session, repeatTimeOut uint64) error
}
```

## Как всё используется на высоком, клиентском уровне.

На этом уровне операторы проходят следующий цикл:

1. Создают новую сессию или получают готовый объект с ней.
2. Проводят операции Append/Replace, руководствуясь указаниями потребителей.
3. В конце либо удаляют её, либо задают повтор.

А есть ещё процессы подчистки, которые ищут подвисшие в активном состоянии и никем более не обрабатываемые
сессии. Алгоритм работы которых довольно прост:

1. Нашли подвисшую сессию.
2. Задаём ей повтор.

Таким образом, встаёт задача нахождения таких сессий. К счастью, её решение разбирается в этом же документе.

А далее переходим к сути.

## Как происходит выполнение операции:

1. Клиент дёргает один из методов, т.е. запрашивает выполнение операции над состоянием. 
2. Оператор кодирует описание операции.
3. Операция подтверждается с использованием кодированных данных операции. Это включает в себя:
   1. Отправка кодированной операции последователям. Только в кластерном режиме.
   2. Ожидание подтверждения от последователей. Только в кластерном режиме.
   2. Сохранение кодированной операции в лог операций.
3. Оператор применяет операцию к состоянию.
4. Потребителю отдаются нужные данные.
5. Потом потребитель может что-то ещё ответить и по результатам ответа решается, что делать дальше.


Заметим, что из всех этих этапов только второй может вызвать ошибочное состояние:
 - Не получилось сохранить кодированные данные.
 - В случае кластерного режима:
   - Не удалось отправить кодированную операцию.
   - Последователи не подтвердили операцию.
   - Последователи не смогли отправить подтверждение.
Но это неважно, наверное. Потому что в операторе мы никогда не выходим с ошибками, кроме случая когда ошибок много.
Но этот случай ведёт к аварийному корректному останову системы.

# LLD.

Так как операции над состоянием не могут осуществляться одновременно, необходимо ожидание своей очереди.
Т.е. оператор должен:

1. Дождаться очереди.
2. Закодировать данные своей операции.
3. Отправить запрос на подтверждение и дождаться его.
4. Выполнить изменение состояния.
5. Посоветоваться с управляющим, что делать раньше.
   6. Если насоветована новая операция, то повторяем сначала. 
   7. А если было удаление сессии любого типа, то просто заканчиваем игру.

В процессе могли происходить ошибки, в таком случае оператору ставится задача выполнить сохранение сессии, он
будет это делать хоть до второго пришествия. Это и решает поставленную выше задачу по недопущению отвалившихся
сессий: оператор ведущий сессию не уходит до тех пор, пока сессия жива.

Наиболее узким местом в этом списке является синхронное по устройству взаимодействие через сеть с последователями: 
абсолютно критично уметь делать меньшее число системных вызовов при отправке. 

Это означает, что принимающая следующего из очереди сторона должна получать сразу несколько подписчиков за один раз.
Т.е. принимается несколько операторов из очереди. В таком случае имеет смысл иметь двойную очередь:

1. Первая очередь принимает какое-то количество операторов.
2. Эти операторы сразу кодируют свои данные.
3. Для кластерного режима здесь можно сразу составить запрос к последователям.
4. Дожидаемся во второй очереди для подтверждения операций.
5. Проводим работу по подтверждению.
   1. Для кластерного режима проводим взаимодействие с последователями.
   2. Пишем данные в лог операций.
6. Применяя операторы последовательно изменяем состояние.
7. Отдаём свою очередь следующей партии операторов ожидающих подтверждения для своих операций.
8. После этого оператор должен посовещаться с управляющим и т.д. как уже было описано.
