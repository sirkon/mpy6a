# Хранение данных

## Общее

Введём "ключ состояния":

```go
// StateID "ключ" состояния лидера, учитывающий срок и текущий индекс операции. 
type StateID struct {
	Term  uint64
	Index uint64
}
```

## Типы данных

Данные делятся на два типа:

* Данные активных сессий.
* Данные незавершённых сессий — далее просто "сессий" — они лежат в файлах.
* Данные описывающие состояние файлов хранящих данные, они же "дескрипторы".

## Хранение данных сессий.

Данные **неактивных** сессий с временем повтора ΔT хранятся в файлах привязанных к значению
ΔT. Т.е. сессии с одним временем повтора **могут** храниться в одном файле, сессии
же с разным временем повтора **никогда** не буду храниться в одном файле.

Записи сессий упорядочены по времени повтора, т.е. если запись сессии S₁ с временем повтора T₁ лежит перед записью
сессии S₂ с временем повтора T₂, то T₁ ⩽ T₂.

Например, если у нас есть сессии с временем ожидания перед повтором в 30с и в 1м, то для хранения могут использоваться
следующие файлы:

* 30@2022042817.data – здесь хранятся данные сессий с повтором через 30 секунд.
* 60@2022043000.data – здесь хранятся данные сессий с повтором через 60 секунд, т.е. через 1 минуту.

Данный подход вызван тем, что сессии должны проигрываться в соответствии с желаемым временем повтора, а если писать 
всё в один файл, то порядок будет нарушен при, например, сохранении сессии с повтором через 60 секунд и через секунду 
будет записана сессия с повтором через 30 секунд и восстановление порядка станет ещё одной трудоёмкой задачей.


Данные сессии для записи имеют следующий формат сериализации:

| Время запланированного повтора (uint64) | Срок лидера (uint64) | Индекс сессии в сроке (uint64) | Топик сессии (int32) | Количество попыток восстановления (uvarint) | Длина бинарных данных (uvarint) | Бинарные данные (bytes) |
|-----------------------------------------|----------------------|--------------------------------|----------------------|---------------------------------------------|---------------------------------|-------------------------|

Время от времени запись в файл с данными сессий прекращается и происходит переключение на следующий файл. 
Операции с файлами входят в лог операций, т.е. набор файлов на лидере и на полностью синхронизированном ведомом узле
идентичен: одинаковые имена, одинаковые размеры, одинаковое до последнего байта содержимое.

## Хранение данных состояний записи и чтения сессий

Данные состояний представляются в виде:

```go
type StorageState struct{
	Name    string  // Название файла. Должно быть уникальным.
	ID      StateID // Ключ состояния лидера, в рамках которого была выполнена операция создания файла.
	LastID  StateID // Ключ состояния лидера, в рамках которого была выполнена последняя операция с файлом. 
	RWState bits    // Производится ли запись в данный момент, производится ли чтение.
	Offset  uint64  // Позиция чтения из файла.
	Len     uint64  // Длина файла.
	Replay  uint64  // Время, которое гарантированно НЕ БОЛЬШЕ чем время повтора первой сессии в данном файле.
}
```

Данные состояний **всегда** в полном объёме присутствуют в оперативной памяти:

```go
var storageStates map[time.Duration]*LinkedList[StorageState]
```

Где реализация `LinkedList` обеспечивает быстрое получение последнего элемента (хранит ссылку на него). С помощью
данных состояний определяется порядок файлов — по параметру Replay.

Персистентное хранилище лога состояний распределено между **снапшотом** и **логом изменений**. Время от времени текущее 
состояние сбрасывается в снапшот и производится удаление текущего содержимого лога состояний.

Если рассмотреть все файлы привязанные к определённому `time.Duration`, то "глобальный" порядок записей в них 
соответствует порядку этих файлов, т.е. все время проигрывания любой из записей в файле A, адресуемом StorageState,
не превосходит самого раннего повтора в файле B, который "следует после" файла A в связнном списке для данного 
`time.Duration`.

### Снапшот данных состояний

Бинарные данные элементов снапшота сериализуются как

| Длина имени (uvarint) | Данные имени (bytes) | Term (uint64) | Index (uint64) | LastTerm (uint64) | LastIndex (uint64 | RWState (byte) | Offset (uvarint) | Len (uvarint) | Replay (uint64) |
|-----------------------|----------------------|---------------|----------------|-------------------|-------------------|----------------|------------------|---------------|-----------------|

Сам снапшот хранит последовательность таких элементов.

### Лог изменений данных состояний

Лог изменений содержит следующие операции:

* Создать на запись файл A (replayTimeout, currentTime)
* Прекратить запись файла A (name)
* Прекратить чтение и удалить файл A (name)
* Открыть на чтение файл A (name)
* Сдвинуть позицию чтения в файле A (name, offsetDelta)

## Хранение данных активных сессий.

Данные активных сессий хранятся в оперативной памяти. Сессия содержит следующие аттрибуты:

```go
type Session struct{
	ID         StateID // Ключ состояния лидера, в рамках которого была выполнена операция создания данной сессии.
	Topic      int32   // Топик сессии.
	LastChange StateID // Ключ состояния лидера, в рамках которого была выполнена последняя мутация данной сессии.
	Data       []byte  // Бинарные данные сессии.
}
```

Данные всех активных сессий хранятся в словаре

```go
var sessions map[StateID]*Session
```




