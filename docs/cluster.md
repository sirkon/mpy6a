# Кластер.

Кластер построен на реализации протокола консенсуса RAFT, с узлом-лидером и узлами-последователями, где последователи
всегда делегируют работу лидеру кластера и выполняя работу по подтверждению изменения состояния от лидера.

## Кластер. Идентификатор состояния.

При старте ноды вычисляется специальное значение:

| Время в миллисекундах (uint64) | Счётчик операций = 0 (uint64) |
|--------------------------------|-------------------------------|

Которое становится т.н. "идентификатором состояния" ноды. Т.к. время в условиях RAFT между узлами кластера обязано
быть синхронизированным, эта величина будет одинаковой на всех узлах.

1. При работе кластера, ведомые узлы отказываются от своего идентификатора в пользу идентификатора лидера кластера.
2. Раз в секунду на узле-лидере идентификатор заменяется на новое значение в миллисекундах, а счётчик обнуляется. 
3. При проведении операций счётчик инкрментируется. Если происходит его переполнение, т.е. он из не нуля становится 
   нулём, то происходит инкремент первого компонента. Это крайне маловероятное событие само по себе, т.к. выполнить 2^64
   операций в рамках практических ограничений невозможно.

Таким образом принимаем, что идентификаторы состояний упорядочены и идентификатор предыдущего состояния всегда меньше
в смысле uint128 чем идентификатор текущего.

## Узел. Подключения узла.

Узел должен иметь подключения к другим узлам кластера. Узел считается не функционирующим, если количество подключений
к другим узлам данного кластера меньше величины кворума в рамках этого кластера.

## Узел. Состояние узла.

Состояния делятся на две части:

* Сохранённые на файловую систему (данные незавершённых сессий — хранилище, данные состояния хранилища).
* Находящиеся в памяти сессии находящиеся в процессе работы, как новые, так и проходящие повтор.

Всё это работает по следующим правилам:

* Открытие новой сессии производится исключительно в памяти.
* Добавление и сброс сессии производятся только в памяти.
* При успешном завершении сессии её данные удаляются из памяти и **не** сохраняются в хранилище.
* При команде о неуспехе, а так же при отвале клиента накопленные данные сессии сбрасываются в файловое хранилище.
* В операции повтора сессии выполняется следующее
  ```mermaid
  flowchart TD
    A[Вычитываем данные сессии] --> B{Если она\nпревзошла\nлимит повторов}
    B --> |Превзошла| C[Выполняем какие-нибудь\nдействия, например\nпредупреждение\nв логе]
    C --> |Ошибка| Stop
    C --> |Успешно| Exit[Помечаем\nсессию\nвыполненной]
    B --> |Не\nпревзошла| SL{Ищем подписчиков\nна топик сессии}
    SL --> |Нашли| Send[Шлём ему\nданные\nи проводим\nвзаимодействие]
    Send --> OnSuccess{Сессия\nзавершена}
    OnSuccess --> |Да| Exit
    OnSuccess --> |Не\nзавершена\nили\nошибка| Leave[Сохраняем\nсессию с\nновыми\nпараметрами]
    Leave --> |Успешно\nсохранено| Exit
    Leave --> |Не\nсохранено| Stop[Останов]
    Exit --> Stop
    SL --> |Не нашли| Leave
  ```

Здесь:

* "Сохраняем сессию с новыми параметрами" означает скинуть сессию с увеличенным на единицу счётчиком повторов и новым 
  временем повтора в соответствии с политикой топика сессии.
* "Пометить сессию выполненной" означает произвести сдвиг в данных состояний на размер сессии для файла из которого она
  была извлечена.


