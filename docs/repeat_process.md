# Повтор сессий.

Задачей повтора является запуск повтора сессий, когда приходит время для этого. Определение пришедшего времени
возложено на состояние, которое:

- Сохраняет сессии.
- Через него обеспечивается поиск готовых к повтору сессий, а поиск делается на всех итераторах.

Т.е. состояние знает время ближайшего повтора. И это даёт возможность вовремя сигнализировать об его необходимости.

## Проведение повтора.

Система имеет какой-то внутренний индекс повтора. Он равен времени повтора у последней сессии пошедшей в повтор.

Система так же знает, когда должно произойти ближайшее время повтора. Дождавшись его, она добавляет операцию по 
извлечению и повтору сессий на это время. Заметим, что операция по повтору сессий так же проставляет "новое" значение
индекса повтора – потому что она читает итераторы.

### Алгоритм нахождения сессий для повтора.

У нас есть некоторое ограничение на максимальное количество сессий, которое можно повторить на текущий момент.
Разумнее всего полагаться в этом на артель (это я так называю "worker pool" – ибо нечего тут): она содержит количество
свободных на данный момент работников. Соответственно, извлекаемое кол-во сессий не может быть выше этого числа. Если
ни один из работников не свободен, ждём освобождения хоть кого-нибудь.

```go
func (s *State) findRawSessions(repeatTime uint64, limit int) (data [][]byte, error) {
    nextRepeat := s.firstRepeat
	
    for i, iter := range s.iterators() {
        // Пробегаемся по итераторам
        for iter.Next() {
            t, sd := iter.SessionData()
            if t == repeatTime {
                // Нашли запись с нужным временем.
                if len(data) == limit {
                    // Эта ситуация означает, что своё мы уже набрали, а сессии с повтором
                    // в искомое время ещё имеются. В таком случае не меняем индекс
                    // повтора, выходим с лутом сразу.
                    return data, nil
                }

                // Пока свободных работников ещё хватает.
                data = append(data, bytes.Clone(sd))
                iter.Commit()
                continue
            }

            // Время больше, чем мы ищем. Но по крайней мере можем оценить,
            // когда должен быть следующий повтор.
            if nextRepeat == 0 || nextRepeat > t {
                nextRepeat = t
                break
            }
        }
		
		if err := iter.Err(); err != nil {
		    return errors.Wrap(err, "iterate with iterator").Int("failed-iterator-index", i)
        }
    }

    if nextRepeat != 0 {
        s.firstRepeat = nextRepeat
    }

    return data, nil
}
```

Здесь, обратите внимание, у нас в приоритете сессии из одного источника, мы вначале выбираем всё актуальное из
ближайшего, перед тем как перейти к следующему.

### Шаги после того как сессии найдены и раскодированы.

После этого мы сооружаем оператор, который зашлёт операцию повтора в первую очередь и исполнит их.

## Повторы.



```go
func (s *State) repeatHandler() {
    for {
        select{
        case <-s.done:
             return
        default:
        }
        
        aim := s.astro() // это время всегда округлено до секунды
        aimsec := uint64(aim.Unix())
        firstRepeat := atomic.LoadUint64(&s.firstRepeat)
        // Возможны только две ситуации:
        //  1. repeatID <= firstRepeat <= aimsec
        //  1. repeatID <= aimsec < firstRepeat
        // Появляющиеся повторы при этом никак не могут
        // быть раньше чем aimsec.
        // Поэтому ждём до начала следующей секунды во втором случае, или
        // начинаем исполнять в первом.
        switch {
        case aimsec < firstRepeat:
            s.waitTillNextSecond()
        default:
            s.repeatID = firstRepeat
            if err := s.repeat(); err != nil {
                // Какая-то ошибка, подробности будут выяснены по мере
                // реализации.     
            }
        }
    }
}
```



