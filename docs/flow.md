# Старт системы в автономном режиме.

1. Старт системы начинается с чтения лога содержащего названия слепков. Подробнее [здесь](logs.md).
2. После этого [состояние](state.md) восстанавливается из слепка.
3. Читается до конца лог операций, формируя актуальное на конец предыдущего цикла функционирования состояние.
4. Запускаются фоновые процессы:
   - Простановка актуального [астрономического времени](state.md#время-системы).
   - Запускается подсистема заведующая слиянием файловых источников повторов. Подробнее 
     [здесь](saved_sessions_storage.md).
   - Запускается подсистема инициирующая [повторы сессий](repeat_process.md).
   - Запускается подсистема создания слепков состояний и ротации лога операций. Подробнее [здесь](snapshots.md).

# Старт системы в кластерном режиме последователем.

1. Совпадает с автономным.
2. Совпадает с автономным.
3. Подключаемся к кластеру и запрашиваем у лидера события следующие за последним имеющимся у нас. Лидер
   отвечает циклом событий `InstallSnapshot`, в которых довозятся
    - Полный слепок со всеми источниками и логом операций, если события были слишком далеко в прошлом.
    - Просто часть лога с событиями, если запускающийся узел не слишком отстал за время отключки.
   При этом параллельно получаем `AppendEntries` – в новый лог, не применяя их – потому что состояния чтобы
   их применять пока нет. Их не подтверждаем при этом.
4. После синхронизации данных переключаемся на новый лог и становимся полноправным последователем.
5. Запускаемые фоновые процессы не отличаются от автономного режима, кроме отсутствующего фонового режима
   проведения повторов. Фоновые режимы сброса контейнера, слияния и создания слепков/ротации запущены и работают 
   так же как в автономном режиме.
6. Приходящие в `AppendEntries` записи последовательно раскодируются и кладутся в очередь – но только те, чей индекс
   не больше чем `commitIndex` пришедший от лидера. 

# Переход системы последователя в лидеры кластера.

Здесь мы только запускаем фоновый процесс поиска повторов.

# Переход системы из лидера в последователя.

Останавливаем процесс поиска повторов немедленно.

# Функционирование системы.

- Внешние управляющие создают свои [операторы](operator.md).
- Подсистема повтора создаёт свои операторы.
- Все эти операторы отправляются в [очередь](operations_flow.md) и последовательно исполняются.

# Завершение работы системы.

- Закрываем канал done в состоянии.
- Дожидаемся завершения работы фоновых подсистем – имеем `sync.WaitGroup` для этого.
- Сбрасываем буфера и делаем fsync для их файлов.
- Выход.

