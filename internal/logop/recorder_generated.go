// Code generated by fenneg version (devel). DO NOT EDIT.

package logop

import (
	"encoding/binary"

	"github.com/sirkon/errors"
	"github.com/sirkon/mpy6a/internal/types"
	"github.com/sirkon/varsize"
)

const (
	logopCodeDelete  = 1
	logopCodeNew     = 2
	logopCodeRecord  = 3
	logopCodeRestore = 4
	logopCodeStore   = 5
)

// Delete encodes arguments tuple of this method.
func (r *Recorder) Delete(sid types.Index) []byte {
	buf := r.allocateBuffer(4 + 16)

	// Encode branch (method) code.
	buf = binary.LittleEndian.AppendUint32(buf, uint32(logopCodeDelete))

	// Encode sid(types.Index).
	buf = types.IndexEncodeAppend(buf, sid)

	return buf
}

// New encodes arguments tuple of this method.
func (r *Recorder) New(theme uint32) []byte {
	buf := r.allocateBuffer(4 + 4)

	// Encode branch (method) code.
	buf = binary.LittleEndian.AppendUint32(buf, uint32(logopCodeNew))

	// Encode theme(uint32).
	buf = binary.LittleEndian.AppendUint32(buf, theme)

	return buf
}

// Record encodes arguments tuple of this method.
func (r *Recorder) Record(sid types.Index, data []byte) []byte {
	lenData := varsize.Len(data) + len(data)
	buf := r.allocateBuffer(4 + 16 + lenData)

	// Encode branch (method) code.
	buf = binary.LittleEndian.AppendUint32(buf, uint32(logopCodeRecord))

	// Encode sid(types.Index).
	buf = types.IndexEncodeAppend(buf, sid)

	// Encode data([]byte).
	buf = binary.AppendUvarint(buf, uint64(len(data)))
	buf = append(buf, data...)

	return buf
}

// Restore encodes arguments tuple of this method.
func (r *Recorder) Restore(n uint32) []byte {
	buf := r.allocateBuffer(4 + 4)

	// Encode branch (method) code.
	buf = binary.LittleEndian.AppendUint32(buf, uint32(logopCodeRestore))

	// Encode n(uint32).
	buf = binary.LittleEndian.AppendUint32(buf, n)

	return buf
}

// Store encodes arguments tuple of this method.
func (r *Recorder) Store(sid types.Index, repeat uint32) []byte {
	var key int
	if repeat != 0 {
		key = varsize.Uint(repeat)
	}
	buf := r.allocateBuffer(4 + 16 + key)

	// Encode branch (method) code.
	buf = binary.LittleEndian.AppendUint32(buf, uint32(logopCodeStore))

	// Encode sid(types.Index).
	buf = types.IndexEncodeAppend(buf, sid)

	// Encode repeat(uint32).
	if repeat != 0 {
		buf = binary.AppendUvarint(buf, uint64(repeat))
	}

	return buf
}

// RecorderDispatch dispatches encoded data made with Recorder
func RecorderDispatch(disp Logop, rec []byte) error {
	if len(rec) < 4 {
		return errors.New("decode branch code: record buffer is too small").Uint64("length-required", uint64(4)).Int("length-actual", len(rec))
	}

	branch := binary.LittleEndian.Uint32(rec[:4])
	rec = rec[4:]

	switch branch {
	case logopCodeDelete:
		// Decode sid(types.Index).
		var sid types.Index
		if len(rec) < 16 {
			return errors.New("decode Delete.sid(types.Index): record buffer is too small").Uint64("length-required", uint64(16)).Int("length-actual", len(rec))
		}
		types.IndexDecode(&sid, rec)
		rec = rec[16:]

		if len(rec) > 0 {
			return errors.New("decode Delete: the record was not emptied after the last argument decoded").Int("record-bytes-left", len(rec))
		}

		if err := disp.Delete(sid); err != nil {
			return errors.Wrap(err, "call Delete")
		}

		return nil

	case logopCodeNew:
		// Decode theme(uint32).
		var theme uint32
		if len(rec) < 4 {
			return errors.New("decode New.theme(uint32): record buffer is too small").Uint64("length-required", uint64(4)).Int("length-actual", len(rec))
		}
		theme = binary.LittleEndian.Uint32(rec)
		rec = rec[4:]

		if len(rec) > 0 {
			return errors.New("decode New: the record was not emptied after the last argument decoded").Int("record-bytes-left", len(rec))
		}

		if err := disp.New(theme); err != nil {
			return errors.Wrap(err, "call New")
		}

		return nil

	case logopCodeRecord:
		// Decode sid(types.Index).
		var sid types.Index
		if len(rec) < 16 {
			return errors.New("decode Record.sid(types.Index): record buffer is too small").Uint64("length-required", uint64(16)).Int("length-actual", len(rec))
		}
		types.IndexDecode(&sid, rec)
		rec = rec[16:]

		// Decode data([]byte).
		var data []byte
		{
			size, off := binary.Uvarint(rec)
			if off <= 0 {
				if off == 0 {
					return errors.New("decode Record.data([]byte) length: record buffer is too small")
				}
				return errors.New("decode Record.data([]byte) length: malformed uvarint sequence")
			}
			rec = rec[off:]
			if uint64(len(rec)) < size {
				return errors.New("decode Record.data([]byte) content: record buffer is too small").Uint64("length-required", uint64(size)).Int("length-actual", len(rec))
			}
			data = rec[:size]
			rec = rec[size:]
		}

		if len(rec) > 0 {
			return errors.New("decode Record: the record was not emptied after the last argument decoded").Int("record-bytes-left", len(rec))
		}

		if err := disp.Record(sid, data); err != nil {
			return errors.Wrap(err, "call Record")
		}

		return nil

	case logopCodeRestore:
		// Decode n(uint32).
		var n uint32
		if len(rec) < 4 {
			return errors.New("decode Restore.n(uint32): record buffer is too small").Uint64("length-required", uint64(4)).Int("length-actual", len(rec))
		}
		n = binary.LittleEndian.Uint32(rec)
		rec = rec[4:]

		if len(rec) > 0 {
			return errors.New("decode Restore: the record was not emptied after the last argument decoded").Int("record-bytes-left", len(rec))
		}

		if err := disp.Restore(n); err != nil {
			return errors.Wrap(err, "call Restore")
		}

		return nil

	case logopCodeStore:
		// Decode sid(types.Index).
		var sid types.Index
		if len(rec) < 16 {
			return errors.New("decode Store.sid(types.Index): record buffer is too small").Uint64("length-required", uint64(16)).Int("length-actual", len(rec))
		}
		types.IndexDecode(&sid, rec)
		rec = rec[16:]

		// Decode repeat(uint32).
		var repeat uint32
		if len(rec) > 0 {
			size, off := binary.Uvarint(rec)
			if off <= 0 {
				if off == 0 {
					return errors.New("decode Store.repeat(uint32): record buffer is too small")
				}
				return errors.New("decode Store.repeat(uint32) - optional repeat timeout: malformed uvarint sequence")
			}

			repeat = OptionalRepeat(size)
			rec = rec[off:]
		}

		if len(rec) > 0 {
			return errors.New("decode Store: the record was not emptied after the last argument decoded").Int("record-bytes-left", len(rec))
		}

		if err := disp.Store(sid, repeat); err != nil {
			return errors.Wrap(err, "call Store")
		}

		return nil

	default:
		return errors.Newf("invalid branch code %d", branch).Uint32("invalid-branch-code", branch)
	}

	return nil
}
