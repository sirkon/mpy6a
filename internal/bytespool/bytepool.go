package bytespool

// New конструктор пула с начальным размером в байтах.
func New(init int) *Pool {
	return &Pool{
		data: make([]byte, init),
	}
}

// Pool сущность для выделения слайсов байт.
//
// Предполагается, что эта сущность работает в определённом
// кванте исполнения и выделяемые данные используются только
// в рамках этого кванта.
//
// Как правило, должен быть вызов Reset перед началом
// использования этого объекта в рамках кванта.
type Pool struct {
	data []byte
	cur  int
}

// Alloc выделяет запрошенное количество байт.
// Если в текущем буфере не хватает данных, он будет
// заменён на новый, в полтора раза длиннее.
//
// Данные метод не является безопасным с точки зрения
// конкурентного использования, клиенты должны сами
// её, безопасность, обеспечивать.
func (p *Pool) Alloc(n int) []byte {
	if cap(p.data)-p.cur < n {
		baselen := cap(p.data)
		if baselen < n {
			baselen = n
		}

		// Мы просто выделяем новую область памяти и сбрасываем
		// начало в ноль.
		// Предыдущий буфер будет подчищен после того, как
		// будут освобождены выделенные оттуда области памяти.
		p.data = make([]byte, baselen*3/2)
		p.cur = 0
	}

	newlen := p.cur + n
	res := p.data[p.cur:newlen]
	p.cur = newlen
	return res
}

// Len возвращает текущий размер выделенных данных.
func (p *Pool) Len() int {
	return p.cur
}

// Cap возвращает текущий размер буфега.
func (p *Pool) Cap() int {
	return cap(p.data)
}

// Available возвращает объём остатка данных в байтах.
func (p *Pool) Available() int {
	return cap(p.data) - p.cur
}

// Reset сбрасывает буфер в состояние "ничего ещё не выделялось".
func (p *Pool) Reset() {
	p.cur = 0
}
